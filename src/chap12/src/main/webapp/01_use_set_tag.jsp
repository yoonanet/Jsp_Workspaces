<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%-- taglib 디렉티브가 jstl에서 활용됨(jstl라이브러리를 포함시키는 기능이 taglib디렉티브인 것이다.) 
     => jstl에서 사용을 하려면 prefix와 url의 속성을 사용하도록 한다.
	 
	 prefix가 접두어임. 접두어로 뭐를 사용할지 적어주는 것이다. 일반적으로 접두어로 권장하는 키워드가 core에서는 c인 것이다.
     => 다른 키워드로 사용해도 상관은 없지만 관용적으로 개발자들간에 jstl라이브러리를 사용할 때 암묵적인 약속으로 지정된 접두어로 넣어주도록 하자!!
     uri는 core에 관련된 기능들을 제공해주는 사이트의 링크(도메인의 위치 정보)를 넣어준다. 
     =>태그에 대한 동작의 정의는 uri사이트에 정의되어있다고 알려주는 개념이다.
     
     
      --%>
     
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page import="model.Member" %>
<%@page import="java.util.HashMap"%>    

<%
	Member member = new Member();

	HashMap<String, String> pref = new HashMap<>();
%>
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>jstl - set 태그</title>
</head>
<body>

    <%-- 위에서 지정한 접두어에 ':'를 통해 접근하도록 함. 
    	 액션태그는 jsp에서 사용할 수 있는 태그로써 jsp:로 접근할 수 있었다. (액션태그는 jsp에 이미 포함하여 제공해주는 태그 라이브러리였음)
    	 jstl은 별도의 외부라이브러리로 추가하여 제공을 해주고 있는 기능의 묶음인 것이다.
    	 
         set태그의 기능은? 자바가 고유하게 사용하는 메모리 영역(3개)과 jsp가 사용하는 메모리 영역(4개)은 다르다. => 데이터의 소멸시점에 따라서 관리하지만 관리 주체가 다름
                       그래서 자바의 선언한 변수를 jsp에서 다이렉트로 사용할 수 없었음. 그래서 자바에 정의된 데이터를 jsp에서 가져올 수 있는 방법이 없었음 
                       => 자바에 변수에 담겨져 있는 데이터를 html브라우저에 출력하려면 표현식이나 표현언어를 이용해서 출력하는 것만 가능했었다.
                       
                       ***jstl에서 제공해주는 set이라는 태그는 자바와 jsp의 데이터를 서로 연결해서 사용할 수 있는 가교역할을 해주는 기능이다.
                       jsp에서 자바프로그램을 작성할 수 있는데 자바에 보관되고 있는 데이터를 jsp에서 다이렉트로 데이터를 가져와서 활용하는 일은 빈번하기 때문에 아주 유용한 기능임. 따라서 거의 필수적으로 활용되어진다.
                       
                       value, var, scope는 set이라는 것을 사용하는데에 있어서 필수로 사용하는 속성이다.
                       value속성을 통해서 자바의 변수를 읽어올 수 있음 -> 표현식을 통해서 값이 출력되는 순간 value에 보관하도록 한다.
                       가져온 값이 value에 담겨져 있을 때, value에 접근할 고유의 이름을 var에 지정하도록 한다. 
                       => 일반적으로 인스턴스의 이름과 동일하게 지정하도록 한다. (지금은 개념을 이해하기 위해서 다르게 지정하도록 함.)
                       
                       value는 자바의 값을 보관하고, jsp에서는 coremember의 이름으로 접근해서 사용을 하겠다고 하는 jsp의 변수를 선언해준 것이다. 
                       ***자바와 jsp간에 접근가능한 환경을 제공하도록 하는 것임 
                       
                       어느 영역에 보관을 할지는 scope속성으로 지정하도록 한다. 
                       -> 일반적으로는 request영역에 담아줌 
                       (이 데이터는 페이지를 완성하기 위해서 임시적으로 선언한 것이기 때문에 응답을 보내고 나면 더 이상 보관할 필요가 없음
                        또한, 현재 페이지를 요청했지만 때에 따라서 forward하여 다른 페이지로 이동할 때 지금 지정한 값을 사용할 수 있도록 request영역에 담아주도록 한다.)
                       
                       지금 현재 set태그는 변수선언으로 태그 사이에 별도로 텍스트노드나 추가적으로 표시할 내용이 없기 때문에 단독태그로써 활용을 하도록 한다.
                       set태그를 단독태그로 만드는 방법 태그 자동완성 후 그 뒤에 '슬래시(/)' 만 쳐주면 됨. 
                        --%>
	<c:set value="<%= member %>" var="coreMember" scope="request" />
	
	<%-- ***set태그를 이용해서 var로 변수를 하나 선언을 했다고 한다면 jstl라이브러리에서 장점 중 하나가 표현언어를 사용할 수 있도록 호환성있게 제공을 해주고 있다.
	        따라서 set으로 선언한 변수도 표현언어${} 안에서 사용을 할 수 있다.
	     
	     target에 set에서 선언한 변수(참조변수)를 표현언어를 통해서 넣어주고, property에 name(getter메소드의 이름에서 프로퍼티의 이름)을 넣어주게 된다면
	     target을 통해 지정한 변수에는 참조변수가 담겨있기 때문에 클래스에 접근해서 프로퍼티의 이름이 name이기 때문에 첫글자를 대문자로 변환하고 getter메소드를 호출해주게 된다.
	     ***그렇게 value에 값을 넣어주게 되면 setter메소드를 호출하면서 데이터를 저장해준다.
	        또 다른 태그에서도 jstl에서 작성된 변수를 사용할 수 있음
	     
	     이것이 가능한 것이 연결하기 위한 중간 매개체 변수가 있기 때문에 jsp로 접근을 하고 있는 것이다. 
	     jsp의 실질적인 변수는 자바의 주소값을 가지고 있기 때문에 서로 연동을 하면서 별도에 자바코드가 없더라도 값을 셋팅하고, 가져올 수 있는 것이다.
	     즉, set을 통해 연결단계를 만들어서 코드를 작성해가면 간단하게 한 줄로 코드를 작성해갈 수 있다.
	     
	     404 => 페이지 못찾는 에러, 500 -> 문법적 에러
	     지금 에러가 나는 것은 호환성에 대한 에러가 나고 있는 것이다.
	     근본 에러를 보면 정의된 클래스를 찾을 수 없다고 에러를 출력하고 있음 -> 톰캣9와 톰캣10의 큰 변화가 javax를 jakarta로 패키지를 바꾼 것 
	     jstl의 최신 버전인 1.2버전은 javax패키지를 찾게끔 정의가 되어져 있음 -> 그래서 아직까지는 톰캣10버전용으로는 릴리즈가 되어져 있지 않다. 
	     !!그렇다면 톰캣9버전으로 셋팅하도록 하자!!
	     
	     오라클 사에서 10버전 이상부터 적용이 될 수 있는 jstl을 공식적으로 릴리즈하기 전까지는 톰캣 9버전으로 사용을 해야한다. 
	     이 이유 때문에 실제 실무에서 톰캣의 10버전 이상을 적용하지 못하고 있음!!
	     실무에서의 유지보수는 이전에 진행된 프로젝트를 modify를 하여 프로젝트 자체를 가지고 와서 진행을 하게 된다. 
	     그 동안 쌓아왔던 그 회사만이 가지는 히스토리가 그대로 담겨서 프로젝트를 진행할 수 있기 때문이다. (기존 코드대로 가지고 오게 되면 안정적이고, 개발기간을 단축할 수 있음)	     
	     => 지금 현재 톰캣에서 9버전으로 호환성을 위해 셋팅을 한 부분에서 위 상황을 생각해보도록 하자. -> 버전업을 하지 않고, 버전을 다운했던 이유!! (이전에 프로젝트와 호환성을 유지하면서 안정적인 동작을 위해서) --%>
	<c:set target="${ coreMember }" property="name" value="홍길동" />
	회원 이름 : ${ coreMember.name }<br><br>
	
	
	<c:set var="pref" value="<%= pref %>" /> 
	<%-- set은 위와 같은 순서로 속성을 작성하는 것이 일반적이다. (변수(var)의 속성이 먼저오고, 값(value)의 속성이 뒤에 오는 순서!!)
	     ***변수에 주소값을 보관하는 것. -> 주소값을 선언했다고 생각.
	     
	     별도로 scope를 지정하지 않음. 이코드 자체는 실질적으로는 자바 코드 상에서 <% pageContext.setAttribute("pref", pref) %>와 동일한 코드다.
	     default는 페이지 영역(pageContext접근해야함)에 저장함. 
	     스크립트를 최소화하기 위해서 태그의 형태로 제공을 해주고 있는 것임. --%>
	
	
	<!-- pref의 데이터셋에 color라고 하는 속성을 추가하는 개념으로 표현언어를 이용해서 변수를 선언해주는 개념이 되는 것이다.
	
	 favoriateColor변수를 선언하면서 color라는 속성을 추가해줌. -> 값을 저장한 적이 없음(원래는 null값이 저장하게 됨) 
	 원래는 null인데 표현언어로 담아주니까 브라우저상에서는 null값인데도 불구하고 null값을 표시해주지 않는다. -> 이것이 표현 언어의 특징인 것이다.
	 (대부분의 모든 프로그래밍 언어에서는 변수나 속성을 선언만 해놓고 값을 출력해달라고 하면 언어마다의 특색을 가지고 메시지를 띄움)
	 ***변수가 선언되어져 있는데 값이 담겨져 있지 않으면 표현언어에서는 아무값도 출력해주지 않는다는 것이 특징!! -->     
	<c:set var="favoriateColor" value="#{ pref.color }" /> 
						    <%-- value="${ pref.color }" /> 변수선언을 favoriateColor을 가리키게 함. 이 순간 값이 안담겨 있음 -> 이후에 셋팅이 있더라도 아무값이 안담기도록 동작 --%>
	좋아하는 색: ${ favoriateColor }<br>
	
		     
	<c:set target="${ pref }" property="color" value="red" /> <%-- 이 순간에 값을 땡겨와서 보관하는 것이기 때문에 값을 직접적으로 새롭게 담아주지 않으면 null값이 유지가 되는 것이다. --%>   
	설정 이후 좋아하는 색 : ${ favoriateColor }<br> 
	<%-- ${}는 출력되는 값이 아무것도 없음.
	표현언어로 $를 사용하고 있었음. 표현언어의 표시 중에서 #도 사용할 수 있음
	$일때는 변수에 값이 안담겨 있었기 때문에 이후에 셋팅을 해주더라도 변수는 아무 값도 담기지 않도록 동작이 됨.
	이전 변수에 셋팅되어져 있는 그대로 아무값도 담기지 않도록 동작이 된다. 
	#은 값을 가져오는 개념이 아니라 변수를 가리키는지만 확인을 하기 때문에 실행을 하는 순간 해당 메모리에서 값을 가져오는 것이다.
	    (실행할 때마다 액션을 취함)
	
	#,$가 똑같은 표현언어로 제공이 되는데 jstl과 함께 사용을 하면 두드러진 차이점을 알 수 있음 -> 일반적으로는 $로 처리된다.
	$는 메모리에 가서 값을 땡겨온 다음에 그 값으로 계속 유지하면서 사용을 하게 되는 것이다. (값을 가지고 와서 보관하는 개념임) 
	    표현식이 실행되는 시점에 바로 계산을 해서 그 값을 그대로 유지하는 것임
	#은 실행할 때마다 그 실행하는 순간 액션을 취하면서 메모리에 데이터를 가져옴!! (실행하는 순간에 그 시점에 값이 필요한 것이고, 그 시점에 계산을 해주는 개념임)
	(값을 가져오는 개념이 아니라 가리키는 정보만 셋팅을 해서 실행시점에 값을 다시 땡겨옴, 실행시점에 값을 땡겨오는 특징) --%>
	
	
	<%-- remove는 jstl의 set에서 생성된 변수를 제거할 때 활용이 되어진다.
	     set을 통해 생성하는 변수는 여러 영역에 생성이 되어질 수도 있기 때문에 scope속성을 통해 영역을 지정하여 삭제를 해주도록 한다.
	     
	     ***중요) jsp와 표현언어에서는 아무값을 넣어져 있지 않은 변수를 호출했을 때, 
	              아무 값도 출력하지 않는 결과값을 보여주지 않으며 강제로 프로그램을 종료시키지 않음. --%>
	<c:remove var="coreMember" scope="request"/>
	회원 이름 : ${ coreMember.name }<br><br>
	


	





<%-- JSTL(JSP Standard Tag Library / JSP에서 제공하는 고급기능) => 라이브러리이다.
IT에서의 라이브러리는 기능들의 묶음이다. ex) jQuery -> 실력이 출중한 프로그래머들이 자바스크립트의 언어를 가지고 유용하게 사용할 만한 여러 기능들을 구현하여 묶음으로 제공 - 핵심기능이 선택자
일관적인 틀의 형식에 고려하여 체계성을 가지고 처리한 기능들의 묶음일 때 확대하여 프레임워크라고 불러주고 있었음 
=> 자바는 인스턴스라는 데이터를 관리할 수 있게끔 컬렉션프레임워크(모아놨음)로 기능들의 묶음을 제공
   (라이브러리의 범위를 확대 - 라이브러리를 체계성을 가지고 제공해주는 기능들의 묶음)

jsp에서 사용할 수 있는 표준의 태그 형태로 제공해주는 기능들의 묶음을 살펴볼 예정. (형식은 태그임. 액션태그에서 한차례 살펴봤었음)
jstl: 액션태그도 한정이 되어져 있다 보니 태그의 형식을 좀 더 추가해서 전세계의 여러 개발자들이 기능의 묶음으로 제공해주는 라이브러리이다.
      jstl은 관리해주고 있는 표준협회에서 묶음으로 제공해주는 라이브러리로 jQuery처럼 생각
      !!유용하게 사용할 수 있는 기능들을 태그 형태로 추가적인 제공이 되어지는 것임!!

JSTL라이브러리 자체는 크게 분리하면 5가지로 분리할 수 있음.
이 중에서 코드 상에 많이 적용되어지는 기능 -> 코어와 국제화제공해주는 기능들이다. (이 부분들에 포커스를 두고 내용들을 살펴볼 예정)
-> JSTL라이브러리는 jsp에서 사용할 수 있게끔 태그 형태로 정의를 해서 제공을 해주는 라이브러리이고, 
   PDF의 URL에 가서 다운로드를 하여 사용을 할 수 있다!! (스프링에서는 mvnrepository의 홈페이지를 많이 보게 될 것이고, maven환경에서 직접적으로 다운로드를 하여 실시간적으로 사용을 해보게 될 것이다.)
   !!지금은 라이브러리형태로 다운을 받아서 포함시키는 형태로 실습을 할 예정!! 1.2가 최종 릴리즈된 버전
   Files -> jar를 클릭하여 다운로드하면 됨.

자바같은 경우 별도에 라이브러리를 포함시키려면 프로젝트 선택시켜서 빌드패스하여 라이브러리에서 추가를 해줘야 하는 번거로운 작업이 선행되어져야 했었음
웹같은 경우 프로젝트 안에 lib폴더에 라이브러리를 넣어주게 되면 별도의 설정없이 현재의 프로젝트 내에 자동적으로 라이브러리가 포함되어지면서 구동을 시킬 수 있다.

라이브러리를 실습을 통해 배우는 실질적인 이유는 이미 구현해서 제공해주는 기능이기 때문에 필요하면 쉽게 가져가서 사용하는 것이 주 목적인 것이다. 
모델1기반은 자바코드를 배제하고 액션태그와 jstl와 형태로 작성을 하면서 표현언어를 활용하는 형식으로 많이 작성됨.

jstl에서 core(변수지원, 흐름제어, URL처리라는 기능을 제공)에 접두어의 용어로 c가 있음 -> 관련 uri로 웹사이트에 대한 인폼이 제공되고 있음         
***jstl에서 가장 큰 장점이자 가장 많이 사용되어지는 기능이 core의 set이라고 하는 태그이다. --%>

</body>
</html>