<%@ tag language="java" body-content="scriptless" 
	pageEncoding="UTF-8"%> <%-- 텍스트 노드의 영역이 있도록 태그의 형태를 지정하려면 body-content속성을 디폴트의 값으로 정의하면 된다.
	                            body-content의 scriptless: 텍스트노드를 가지는 태그로 설정하겠다는 의미 --%>
<%@ tag trimDirectiveWhitespaces="true" %>
<%@ attribute name="trim"%> <%-- boolean값을 통해서 여백을 제거를 해주도록 하는 속성 요소를 추가함. --%>
<%@ attribute name="length" type="java.lang.Integer"%> <%-- 숫자를 전달받기 위한 속성으로 기본은 문자열로 전달이 되어지기 때문에 숫자형으로 타입을 바꿔주도록 한다. --%>
<%@ attribute name="trail" %>




<%-- 전달받은 텍스트 노드(몸체에 해당하는)를 이 사용자 정의 태그 파일 내에서 어떻게 사용을 할 수 있는가?
***태그 파일 내에서 액션태그를 사용할 수 있다. -> doBody액션태그를 활용하도록 함 (텍스트노드를 전송받는 태그는 doBody임!!)
   doBody액션태그는 body-content속성의 값이 scriptless일 때 텍스트 노드의 값을 전달받는 태그이다. => 전달받은 텍스트 노드의 내용을 변수에 저장함.
   전달받은 데이터를 어느 메모리에 저장할지를 지정하는 것이 scope의 속성!! 
   (태그 같은 경우에는 시작과 끝나는 태그 사이에서만 데이터를 처리하려는 것이기 때문에 일반적으로는 page영역에 보관하게끔 처리한다.) 
   
태그 파일에서 제공하는 기본 객체는 jsp의 기본객체의 이름과 통일을 시켜주고 있다. => 기능도 동일하게 제공.
하나 주의) jsp에서는 4개의 메모리 영역이 있는데 유일하게 page영역만 page기본객체로 접근하는 것이 아닌 pageContext로 접근할 수 있었음
           jsp에서의 pageContext를 태그파일에서는 jspContext로 제공을 해주고 있다.
   --%>
<jsp:doBody var="content" scope="page"/>




<% 
	String content = (String)jspContext.getAttribute("content"); //태그파일의 메모리 키워드로 몸체에 접근!! => 반환형이 Object이기 때문에 전달받아오는 데이터의 자료형으로 강제형변환.
	//jsp에 저장된 메모리 영역에 자바언어로 어떻게 접근할 수 있는지를 기억하고 있는 것이 중요하다!!
	
	if(trim != null && trim.equals("true")) { //옵션의 경우 꼭 null인지 아닌지를 비교하는 구문을 작성하도록 한다. 
		content = content.trim(); 
		//String 자료형 안에 trim()이라는 메소드를 제공해주고 있음 
		//                   => 현재 문자열 데이터에 좌나 우에 여백이 있으면 그 여백을 제거하여 문자열을 반환해줌(문자열의 시작주소값을 반환해주는 것임.)
		//그 여백을 제거한 문자열을 업데이트하기 위해 기존변수에 다시 담아주도록 한다.
	}
	
	/*string자료형 안에서 replaceAll메소드를 제공 => 첫번째 매개변수(정규표현식의 값이 와도 되고 직접적인 특정 문자열이 와도 됨.)로 전달한 값을 두번째 매개변수로 전달한 값으로 대체해달라는 메소드 
	                                               (콘텐츠의 처음부터 끝까지 추적하면서 첫번째 매개변수가 있으면 두번째 매개변수로 다 바꿔줌)
	지금 현재는 태그가 오면 제거를 해주고 싶은 것이기 때문에 제거의 효과는 공백으로 준다.
	정규표현식 - (): 대상의 영역을 지정할 때 사용해준다.
			  	 - ?안에 문자열을 넣어주면 지정한 문자열이 한 번만 올 수도 있고 안올 수도 있다는 의미 (온다면 한차례까지만(!!한번만!!) 올 수 있다는 것임.) 
	           - ([A-Za-z]) 모든 알파벳을 검색 대상으로 지정하겠다는 의미, 알파벳을 만나는 대상에 *을 표시한다면 안올 수도 있고 하나 이상(여러 개)이 올 수 있다고 할 때의 표시로 활용
	시작태그에는 속성을 지정하기 직전에 공백이 오고, 끝나는 태그에서는 공백이 안옴 => 따라서 (\s)?로 지정 
	\s: 공백을 표현하는 정규표현식임 -> 하지만 \는 이스케이프로 인식되기 때문에 \\두번 써주기.
	^ => not의 의미를 가지고 있음. []안에 ^이 오면 ^다음에 오는 기호가 아니면의 의미를 담고 있음 
	[^>] '>' 기호를 만나기 이전에 모든 대상을 선택하겠다는 의미이다. (>가 아닌 대상이 전부 선택이 되어서 제거하는 것이다.)
	하나의 속성을 다 읽어서 제거하고 다시 공백이 오는 순간 (\\s[A-Za-z]*=[^>])?이 다시 실행된다는 것을 유의하자!
	정규표현식의 자주 사용되는 표현이 이 코드 안에 거의 다 녹여져 있기 때문에 이 코드를 기억하도록 하자.	*/
	content = content.replaceAll("<(/)?([A-Za-z]*)(\\s[A-Za-z]*=[^>]*)?>", ""); // <(/)?: 시작태그와 끝태그를 동시에 처리하는 정규표현식임.	
	
			
	//자바5버전부터 autoboxing기능을 통해 래퍼클래스에서 intValue메소드를 호출하지 않아도 값을 꺼내올 수 있음(하위버전의 호환성을 위해 직접적인 호출을 해주도록 한다.)		
	if(length != null && length.intValue() > 0 && content.length() > length.intValue()){ //현재 content에 담긴 문자열 갯수가 length로 지정한 숫자값보다 클 경우에만 수행해주도록 함
		content = content.substring(0, length.intValue()); //substring메소드: 첫번째 문자열부터 카운팅, 값을 꺼내오면 15전달 => 0번째 인덱스의 문자열부터 15의 직전까지 추출하는 것이다.
		//화면의 일정 폭을 넘어가면 전체 문자열이 안보이는데 그 화면의 영역만큼만 출력하고 뒤에는 ...을 붙여서 출력하고 싶은 것이다.
		
		if(trail != null){
			content = content + trail; //추출된 값 뒤에 trail값을 붙이도록 한다.
		}
	}
%>

<%= content %>

