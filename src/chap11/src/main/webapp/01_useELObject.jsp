<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%-- [표현언어의 비활성화]
	 실질적으로 표현언어를 인식하기 시작하는 문법은 톰캣 6.0버전부터 표현언어가 처음 지원되기 시작했다. 
	    코드 상에서 ${}의 기호를 만나면 표현 언어로 무언가의 값을 출력하는 것으로 jsp는 인지하게 됨
	    톰캣5이하버전에서는 표현언어라는 것을 아예 지원을 하지 않았어서 표현언어의 기호를 만나면 텍스트로 인식함
	    
	    기호의 표시${}를 표현언어로 인식할 것인가 인식하지 않을 것인지의 대한 처리에 관련한 실습을 할 예정 
	    ex) 지금 환경을 최신의 환경을 구축하고 있다고 생각. 우리 회사에서 서비스 되어지고 있는 업체가 있는데 유지보수의 요청이 왔다면?
	        그 웹사이트는 5년 이전에 개발을 해줬었던 업체로 톰캣5버전, 6버전 초기로 구축이되어 표현언어가 지원되지 않는 환경에서 개발되어진 프로젝트였다고 가정.
			만약 그 프로젝트에서 소스코드에 ${}가 있었다면 그 프로젝트내에서는 표현언어를 사용하는 의도가 아니라 텍스트형태로 처리하고자 화면상에 구성을 하는 코드일 것이다.  
			지금의 환경에서 import를 하여 위 프로그램을 구동하게 된다면 ${}를 표현언어로 인지하여 이 안에 작성된 내용들을 표현언어로 구동시키려고 할 것이다.  
	        => 유지보수할 프로젝트는 표현언어의 문법 규격에 맞춰서 작성이 안되어 있기 때문에 제대로 실행이 안되면서 오류가 나는 문제점 발생될 것이다.
	        그렇다고 표현언어를 인식하지 못하도록 톰캣 5.0이하버전으로 다운스킬하여 프로젝트의 환경을 맞추게 된다면 
	        지금의 내환경과 이전환경이 혼합이 되어지면서 환경 자체가 호환이 안돼서 충돌이 일어나는 문제점이 발생될 것이다.
	        나에게 별도로 컴퓨터 한 대가 추가적으로 주어지지 않는 이상 프로젝트의 유지보수에 따른 환경을 따로 구축하기는 어려울 것이다.
	    	
	    ***이때, 표현언어라는 기호를 표현언어로 인식하지 않게끔 처리할 수 있는 환경을 추가적으로 제공해주고 있음 (브라우저 입장에서는 텍스트형태로 인식하게끔!!)
	    page디렉티브 주요 속성 중에서 isELIgnored => 이름이 is로 시작하면 결과 값이 boolean로 반환되어지게끔 속성이 셋팅되어져 있다고 생각해도 됨, 
	                                                 표현언어를 무시하겠느냐(표현언어 인식여부 셋팅, 현페이지에서 국한됨)
	                                                 디폴트는 false_무시하지 않겠다는 의미. 따라서 지금 현재 프로젝트에서 표현언어로 인식되는 것임
	                                                 true로 셋팅하면 현 페이지 내에서 ${}표시를 표현언어를 인식하지 않고(무시하게끔) 텍스트로 인식해서 처리됨
	                                                 !!이 설정은 현 페이지 내로 국한됨!!  
	    
	    만약 특정 기능에 표현 언어 자체를 전체적으로 무시하고 싶다면? (설정의 셋팅을 통해 지정하는 방법)  
	    => 아주 낮은 환경에 개발되어진 프로젝트의 파일이 oldversion의 안에 위치했다고 가정. 
	    oldversion폴더 안에 위치하는 모든 jsp파일의 표현언어를 일괄적으로 무시하도록 셋팅을 해주려고 한다면 (한번에 적용하는 방법.)
	    web.xml파일 -> jsp-config속성에 자식으로 jsp-property-group앨리먼트에 url-pattern(속성이 적용될 폴더까지의 경로를 적어주기)
	                                                                          와 el-ignored(표현언어의 무시 여부 - true지정)를 지정해주도록 한다.
	          
<%@ page isELIgnored="true" %> 페이지 자체 내에서의 표현언어의 인식여부를 셋팅해줄 수 있음.

페이지디렉티브에서 deferredSyntaxAllowedAsLiteral속성(디폴트는 false임)은 표현언어와 관련이 있음 : #도 문자열의 값으로 사용을 할지 말지에 대한 지정
false면 표현언어로 사용을 하겠다는 것이고, true면 문자값으로 허용을 하겠다는 의미이다.

표현언어에서 사용기호가 $, #이 있었음
#에서는 JSP 템플릿의 문자열로 사용이 불가하다고 설명이 되어져 있음
=> 따라서 deferredSyntaxAllowedAsLiteral true로 설정을 해봐야 출력이 되지 않는다. jsp에서는 #을 사용하는 경우가 거의 없음 --%>
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>EL Object</title>

<script type="text/javascript">



</script>

</head>
<body>

	<%-- 스크립트요소의 표현식을 대체할 수 있는 언어를 살펴보는 실습이다.
		 표현언어는 ${}형식 안에 사용할 수 있다.
		 
		 표현 언어: ${}는 <%= %>를 대체한다는 의미. 단순히 표현식만 대신한다고 한다면 jsp스크립트 요소를 사용하면 됨.
	     하지만 표현언어는 언어로써의 다양한 추가기능들을 더 제공을 해줌으로해서 단순 출력에 국한되지 않는 것이다.
	     (표현식보다 조금 더 다양한 기능을 제공하는 것임)
	     
	     문법용어로 인식을 하여 계산이 되어 브라우저 화면에 출력되는 것을 확인할 수 있음
	     ${}형태 그대로 화면에 출력하고자할 때(텍스트형태로 인식을 시키고 싶다고 할 때), 표현언어 앞에 역슬래시를 붙여주면 텍스트 그대로 받아들임 --%>
	
	
	
	<%-- [ 산술연산 ] : 동일한 결과 <%= 10 + 2 %>
	     타 프로그래밍과 동일하게 산술적인 계산 기능을 제공해주고 있는 것이다.
	     추가적인 확인) 자바에서는 정수의 나눗셈에서 정수의 몫만을 결과로 피드백해주지만 
	                    자바스크립트와 표현언어는 정수나누기 정수라고 하더라도 실수의 형태로 결과값을 반환해준다.
	                    => 또한, 나눗셈은 div라는 키워드를 이용해서 처리할 수 있다. +) 나머지연산자는 mod라는 키워드로 처리 가능 --%>   
	\${ 10 + 2 } = ${ 10 + 2 } <br> <%-- 산술연산의 기능을 그대로 제공!!
	                                 주의) 이클립스가 표현언어에 대해 완벽하게 지원을 못하고 있어서 어떤 경우에는 에러가 나고 안나는 현상들이 발생이 되고 있음 --%>
	\${ 10 - 2 } = ${ 10 - 2 } <br>
	\${ 10 * 2 } = ${ 10 * 2 } <br>
	\${ 10 / 2 } = ${ 10 / 2 } <br>
	\${ 10 div 2 } = ${ 10 div 2 } <br><br>
	
	\${ 10 % 3 } = ${ 10 % 3 } <br>
	\${ 10 mod 3 } = ${ 10 mod 3 } <br> 
	
	<%-- 타프로그래밍 언어(자바, 자바스크립트)에서는 문자열 + 문자열에 대한 연산이 결합으로 이루어졌었음
	     하지만 표현언어에서는 에러가 발생되어지고 있음. => 즉, 표현언어에서는 문자열의 덧셈 연산을 지원하지 않는다.
	${ "더조은 "+"컴퓨터 학원" }<br> --%>
	
	
	<%-- !!주의!!  
	숫자형문자열 + 숫자로 연산을 하게 되면 "자바"는 문자열의 결합으로 25로 출력되고,
	"자바스크립트"에서는 숫자의 연산으로 수행이되어 7로 출력이 되었음
	"표현언어"는 자바스크립트와 동일하게 숫자형문자열 데이터일 경우에는 자료형을 숫자형으로 강제형변환을 하여 연산을 수행하게끔 내부로직을 처리한다.
	
	그렇기 때문에 표현언어에서 숫자형문자열을 통해 산술연산을 수행을 하게 되면 에러를 내지 않고 계산을 해주게 되는 것이다.(자바는 에러!)  --%>
	\${ "2" + 5 } = ${ "2" + 5 }<br>
	\${ "2" * 5 } = ${ "2" * 5 }<br>
	
	\${ 10 + null } = ${ 10 + null }<br> <%-- null: 어떠한 값도 입력되어있지 않았다는 표시 => 수치의 데이터가 아니기 때문에 이러한 연산을 처리할 수 없었음
	                                          자바나 자바스크립트에서는 에러발생이 됐었음. 하지만 표현언어에서는 10으로 출력됨. null을 0처럼 처리를 하고 있음   --%>

	<%-- \${ "십" + 5 } = ${ "십" + 5 }<br> 문자열 데이터의 연산으로 처리되어 에러발생!!("연산은 숫자만 가능해~" 라고 하면서 에러남.) 
	    
	    문자열의 연결은 아예 지원하지 않는 것일까?
	    EL spec은 2.1부터 시작을 하면서 jsp의 버전과 맞춰갔었지만 3.0버전부터는 문자열 연결을 제공 => 2.3버전 이하부터는 제공하지 않는다. --%>
	
	
	
	
	<%-- 문자열 연결(EL 3.0(JSP2.3 -> tomcat8) 추가)
	표현언어에서는 복합대입연산자(누적)을 활용하여 문자열을 연결하도록 한다. --%>
	\${ "문자" += "열" += " 연결" } = ${ "문자" += "열" += " 연결" }<br><br><br>

	
	<%-- 표현 언어(비교 연산)
	     열린꺽새와 닫힌꺽새의 표시를 브라우저에서 그대로 사용하기 위해서 <는 &lt; >는 &gt;로 활용했었음
	     브라우저상에 <br>을 그대로 출력을 하고 싶다면? &lt;br&gt; --%>
	\${ 10 > 2 } = ${ 10 > 2 }<br>
	\${ 10 gt 2 } = ${ 10 gt 2 }<br><br> <%-- 닫힌 꺽새를 gt로 표현할 수 있음. --%>
	
	\${ 10 < 2 } = ${ 10 < 2 }<br>
	\${ 10 lt 2 } = ${ 10 lt 2 }<br><br> <%-- 열린 꺽새를 lt로 표현할 수 있음. --%>
	
	\${ 10 >= 2 } = ${ 10 >= 2 }<br>
	\${ 10 <= 2 } = ${ 10 <= 2 }<br>
	\${ 10 == 2 } = ${ 10 == 2 }<br>
	\${ 10 eq 2 } = ${ 10 eq 2 }<br><br> <%-- 같은지의 비교연산은 eq의 키워드를 통해 동작시킬 수 있음 --%>
	
	\${ 10 != 2 } = ${ 10 != 2 }<br> &lt;br&gt;
	
	\${ empty("") } = \${ empty("") }<br><br> <%-- 표현언어에서 제공하는 empty()의 기능은 입력으로 들어오는 데이터가 빈 데이터인지 체크하는 용도의 메서드 --%>
	
	
	<%-- 표현 언어(논리 연산) => 피연산자는 boolean값(주로 비교연산자가 옴)
	      &&: 앞, 뒤 모두 true일 때만 true를 반환, 앞과 뒤에 둘 중에 하나라도 false이면 false임(and 키워드로도 동일하게 연산처리 가능)
	      ||: 둘 중에 하나만 true이면 true를 반환해줌 (or 키워드로 동일하게 처리 가능)  --%>
	\${ (2 > 5) && (5 != 4) } = ${ (2 > 5) && (5 != 4) }<br> 
	\${ (2 > 5) and (5 != 4) } = ${ (2 > 5) and (5 != 4) }<br> 
	
	\${ (2 > 5) || (5 != 4) } = ${ (2 > 5) || (5 != 4) }<br> 
	\${ (2 > 5) or (5 != 4) } = ${ (2 > 5) or (5 != 4) }<br> 
	
	
	<%
		request.setAttribute("name", "홍길동"); //map의 형태로 원하는 데이터를 영역에 저장
		pageContext.setAttribute("name", "강감찬");
	%>
	
	<%= request.getAttribute("name") %><br> <%-- 키의 값을 입력으로 넣어주면서 값을 반환하여 출력하도록 함 --%>
	\${ name } = ${ name }<br><br> 
	<%-- 표현언어에 키값을 넣어주면 키에 대한 값을 반환해줌 -> 표현식보다도 간단하게 영역의 데이터 값을 불러낼 수 있음(표현언어를 사용하는 이유가 됨)
	 키값만 넣어줬을 때 표현언어는 jsp메모리 공간에 해당하는 페이지영역부터 name이라는 이름이 영역에 있는지 확인하게 된다. 
	 페이지 영역에 없으면 request 메모리 영역을 보게 되고, 그 request영역에 name이라는 이름이 있기 때문에 불러오게 됨.
	 만약 request영역에 없다면 session영역, session영역에 없으면 application영역을 보게됨. => 표현언어는 해당 메모리 영역을 순차적으로 검색하여 데이터를 꺼내오게 되는 것임.	 
	 따라서 주의) 입력으로 전달한 키값을 찾을 때 page영역 -> request영역 -> session영역 -> application영역순으로 찾음 (순차적 검색)
	              최초로 찾은 데이터 하나만 검색을 해주고 멈추게 된다는 것을 유의하고 있도록 한다.	              
	              
	              유일하게 page만 pageContext로 scope영역에 접근할 수 있는 것도 함께 주의!!
	              두 개 이상의 메모리 영역에 동일한 키값으로 데이터가 저장되어 있다면? 표현언어는 순차적인 검색에서 먼저 찾은 데이터 값을 꺼내온다.
	 
	 따라서 지금 실습에서 보면 페이지와 리퀘스트영역에 같은 이름의 데이터가 저장되어 있지만 
	 우선순위가 높은 페이지영역의 데이터가 출력되는 것을 확인할 수 있다. --%>
	 
	 
	 
	 
	요청 URI(표현식) : 
	<%= ((HttpServletRequest)pageContext.getRequest()).getRequestURI() %><br>
	<%-- 표현식을 이용해서 현재 클라이언트가 요청해온 정보를 출력하고자 함 -> request객체에 getRequestURI()메서드를 통해서 확인을 해봐도 됨
		 request객체를 직접적으로 접근을 해도 되지만,
	     pageContext라는 객체에서 제공되어지는 메서드중에 getRequest메소드를 이용해서도 getRequestURI()메소드를 사용할 수 있었음.
	     pageContext의 두드러진 기능 중에 하나가 나머지 객체들을 반환해주는 메소드를 제공해주고 있었음.
	     
	     getRequest의 반환형이 ServletRequest로 반환해줌. (범용적인 프로토콜 방식을 처리하는 개념으로 제공을 해주고 있기 때문에 자료형의 이름을 반환해줌)
	     우리는 http프로토콜방식에 기반한 통신 프로토콜을 살펴보고 있기 때문에 
	     ServletRequest상속하는 구조로 정의하고 있는 HttpServletRequest의 자료형으로 강제형변환을 해주도록 한다.
	     
	     결과적으로 프로젝트의 이름부터 요청하고 있는 페이지의 정보까지 그대로 출력해주고 있는 것을 확인할 수 있다. --%>
	
	요청 URI(EL) : ${ pageContext.request.requestURI }<br>
	<%-- 표현언어를 활용해서 접근해가는 방법: pageContext객체를 이용해서 최종적인 getRequestURI메소드를 호출해주고자 한다면 서로 간에 다음과 같은 형태로 접근할 수 있다.
		                                      표현1.표현2의 형식을 사용하고 있음.
		                                        
	표현1.표현2의 형식을 사용하게 되면 첫번째 표현1을 값1로 변환한다. 
    (pageContext(참조변수이기 때문)는 엄밀하게 말하자면 주소 값이 저장되어져 있음 -> 값1으로 변환한다는 것을 주소값으로 변환하는 의미로 생각)
	-> 값1이 null이면 아무런 객체도 가리키고 있지 않다는 것이기 때문에 null을 리턴해주게 됨
	-> 값1이 null이 아니라면 주소값을 가지고 있는 것이기 때문에  
	   뒤에오는 표현2를 보면서 값2로 변환한다. (값2가 null이라면 바로 결과로 null로 리턴해주게끔 처리되어짐)
	
	값1이 null이 아닐 경우 값1이 map인지 list인지 배열인지 따져서 그 다음 액션을 취함 
	이 모든게 아니라면 5번으로 와서 값1이 인스턴스의 메모리 시작주소값을 가지고 있는지를 따져보게됨
	
	지금 현재 실습에서 값1이 객체이기 때문에 5번으로 수행하게 된다. -> 값2를 문자열로 변환하게 됨(표현2의 요소를 값2로 변환하는 것) 
	값1의 이름이 값2이고 읽기 가능한 프로퍼티를 포함하고 있다면 프로퍼티의 값을 리턴하게 된다. 그렇지 않은 경우 에러발생
	즉, 지금의 예제에서 보면 request로 써주면 프로퍼티로 인식해주는 것이다.
	
	표현언어는 표현식을 대체하는 것이고, 표현식은 출력이기 때문에 출력의 의미는 getter가 되는 것임.
	문자열로 변환을 해서 문자열을 프로퍼티로 인식을 해서 첫번째 글자를 대문자로 변환해서 맨 앞에 get을 붙이고, 
	이에 대한 메서드가 존재하는지를 확인하여 호출하는 것이다. (프로퍼티의 이름만 써주면 되는 것임)
	즉, 앞이 객체인지 보고 뒤에 오는 값을 프로퍼티로 인식해서 getter메소드를 호출하게 되는 것이다.
	(.을 통해 연결을 해주게 되면 문자열로 바꾸면서 프로퍼티로 바꾸면서 getter메소드를 호출해준다.)
	=> 표현언어로는 프로퍼티이름의 명칭만 적어주면 프로퍼티 속성에 따라서 getter메소드를 호출해주게끔 내부적으로 동작이 되는 것이다.

	즉, 값1이 객체라면 뒤에 오는 값을 프로퍼티로 인식하여 확인하고, getter를 찾아보고 메소드를 호출하게 되는 것이다. (자바빈 규약의 방식을 추가적으로 제공해주는 것임)
	jsp에서 자바의 값을 출력하고 싶을 때는 표현언어를 훨씬 더 많이 활용하게 됨. (스크립트요소는 되도록 배제하려고 함.) => 표현언어가 훨씬 더 단순하게 표현이 되어짐.
	*프로퍼티 => useBean액션태그에서 보면 자식태그는 아니였지만 set프로퍼티, get프로퍼티가 자식처럼 사용하는 태그가 있었음 
	=> set프로퍼티, get프로퍼티가 자바빈을 정의할 때 자동으로 getter, setter메소드를 호출해주는 프로퍼티의 이름을 지정해주는 요소였음
	
	***한번 더 확인)표현언어는 출력이 목적이기 때문에 프로퍼티 규약중에서 출력용으로 getter를 생각하여
	                객체.프로퍼티의 이름으로 명시만 한다면 get프로퍼티로 하는 자식개념의 기능으로 호출하게 되는것
	
	만약 값1이 map, list, 배열의 자료형이라면
	map은 containsKey()메소드를 호출하면서 값2가 입력으로 들어가서 키값의 데이터가 존재하는지를 찾아보게끔 내부에서 수행이 된다. (존재하지 않으면 null을 리턴)
	존재한다면 .get(값2)로 메서드를 호출되어지는 것이다. (키값을 넣어서 키에 해당하는 벨류가 있으면 리턴되어지게끔 수행됨)
	
	값1이 리스트나 배열이라면
	.을 통해 그 뒤에 값2가 정수값인지 검사(정수값이 아니면 에러발생)
	정수값일 때는 값1.get값2 또는 Array.get(값1, 값2)에 결과에 대한 값을 리턴한다. (index에 담긴 정수값을 리턴하는 것.) --%>
	
	
	
	
	
	<%-- 표현언어는 각 영역별로 접근을 하고 싶다면 영역이름 뒤에 Scope를 붙여서 .key값을 통해 value에 접근하여 출력하도록 한다.  --%>
	request의 name(key)의 값(value) : ${ requestScope.name }<br>
		
	<%-- 파라메타의 값을 전달하고 싶다고 한다면 입력양식태그의 name속성에 값을 담아서 브라우저에 주소입력칸 ?뒤로 작성이 되어졌었음 
	     => http://localhost:8090/chap11/01_useELObject.jsp?code=50 직접 작성이 가능.
	     이를 표현식으로 꺼내온다면 아래와 같은 코드를 작성하도록 한다.
	     
	     표현언어에서 param객체는 전송되어지는 모든 파라미터 값을 보관하고 있는 객체이다. => .key값만 적어준다면 파라미터의 값을 출력해주게 되는 것임. (표현식보다 훨씬 더 간단하게 결과값을 출력해줄 수 있음)
	     paramValues => 배열의 형태 값으로 전달되어지는 대표적으로 체크박스의 값을 읽어올 때, getparamValues메소드로 꺼내왔었음
	                    즉, 표현언어에서도 체크박스의 값을 읽어올 때 활용하면 된다. --%>
	code 파라미터(스크립트) : <%= request.getParameter("code") %><br>
	code 파라미터(표현언어) : ${ param.code }<br>
	
	
	
	
</body>
</html>

<%--
실무에서 진행되는 환경은 자바 6버전과 8버전임. => 8버전에 최적화된 톰캣은 9.0버전임
현재의 실습 버전은 스프링과의 연동에서 검증이 되지 않았기 때문에 하위버전을 활용하도록 해야한다.

표현 언어는 jsp에서의 고급기술 또는 고급기능이라고 일컫고 있음 
            스크립트요소를 최소화하면서 간단하게 표현할 수 있도록 함. 현재 추세는 스크립트의 요소를 최소화하여 꾸며줄 수 있도록 함. => 이때 활용하는 것이 표현 언어인 것임

톰캣 사이트에 호환버전 페이지를 보면 EL spec이 표현언어를 말해주고 있는 것이다. 
=> 상당히 뒤에 추가되어진 요소라고 보면 됨(톰캣으로 치면 7버전대에 추가가 되어짐)

그렇다면 표현 언어(Expression Language, EL)란? EL의 핵심은 데이터를 브라우저상에 출력. 
=> 스크립트요소에서 표현식이 있었음. 그 표현식의 영문이 Expression임
  (자바에서 표현되어지는 변수나 자바에 의해서 생성되어진 데이터를 브라우저상에 출력할 때 사용)
jsp페이지 안에 스크립트요소들이 있다보면 기존에 html웹표준의 코드와 자바코드가 뒤섞이면서 상당히 코드의 가독성을 떨어트리는 문제점이 발생됨
그렇기 때문에 스크립틀릿을 최소화하기 위해서 액션태그가 있었음

지금부터 살펴볼 표현언어는 스크립트 요소중에서 표현식의 기호를 최대한 자제하면서 최소화하면서 액션태그처럼
그 기호 대신에 출력을 수행할 수 있게끔 제공해주는 표현방법이다. (대체 표현 수단으로 생각)
단순히 표현만 하는 것이 아니라 언어적인 요소까지를 같이 제공해주는 것이다. 
(웹표준의 자바스크립트가 있듯이 jsp의 언어로 표현 언어를 제공해주게 되는 것임)

표현언어의 주요기능: 수치연산, 관계연산, 논리연산자를 제공

표현언어는 저장되어있는 데이터를 읽어와서 브라우저 출력이 핵심 기능
jsp페이지 내에서 기본 객체를 제공해주고 있었음 아까 표현언어에서 pageContext라는 것을 사용했었음 -> 이름이 동일해서 사용을 할 수 있었음
***표현언어도 ${}안에 별도의 인스턴스를 생성하지 않고 다이렉트로 사용할 수 있는 기본 객체를 제공해주고 있음
=> 표현언어에서의 pageContext는 jsp에서 제공해주는 pageContext기본 객체와 완전 동일한 객체로 제공해주는 것임(그래서 다이렉트 사용이 가능했던 것)
+) pageScope, requestScope, sessionScope, applicationScope 제공 
=> 나머지 4개의 메모리 영역도 scope만 빼면 jsp에서 제공해주는 기본 객체와 동일함. 
   ${}안에서 다이렉트로 사용할 수 있는 기본 객체를 제공해주고 있는 것임 
   
   표현언어는 표현식을 대체하는 용도이고 표현식은 출력의 용도이기 때문에 저장된 데이터를 읽어와서 내 브라우저에 출력하는 것이 핵심 기능이다.
   jsp에서 데이터를 읽어오겠다고 한다면 저장할 수 있는 메모리 영역이 4군데이기 때문에 표현언어에서도 4개의 메모리 영역에 접근해갈 수 있는 
   내장 객체를 제공해주고 있는데 이름도 직관적으로 scope를 붙여주면서 각 메모리 영역에 접근해갈 수 있게끔 제공을 해주는 것이다. 이는 Map객체로써 데이터를 읽어올 수 있다.	
   => ***메모리 영역에 다이렉트 접근을 할 수 있도록 제공해주는 객체들인 것이다.

!!!주의!!!) 표현언어는 스크립트 구성 요소 안에서는 사용할 수 없다. (겹쳐서 사용 불가임. 꼭 기억!!)
            <% ${} %>, <%= ${} %>, <%! ${} %> => 사용불가임.

표현언어는 ${}뿐만 아니라 #{}의 기호도 있음 (브라우저 출력 용도로 체크!!)
하지만 jsp에서는 #을 사용할 일이 거의 없음. 일반적으로 표현 언어로 만나게 될 기호는 $임
#은 변수 값을 출력해달라고 할 때, 그 출력의 값을 출력해달라고 하는 실행 시점에 값을 출력해줌.
(jsp라고 하는 문법요소에서는 텍스트에서는 #이 사용이 안되다 보니 텍스트가 아닌 숫자를 처리하는 일부 영역에서만 기능을 지원하게 된다. 
  -> 사용이 번거로움 -> jsp에서는 #을 거의 사용하지 않는 추세임) 
$는 이전에 저장(보관)하고 있었던 값을 출력해줌
--%>
