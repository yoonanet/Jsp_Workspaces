<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>

<%-- page 디렉티브의 주요 속성 중에 session이 있음.
     => 이 페이지의 요청을 받으면 클라이언트가 사용할 고유 세션 영역을 할당할 것인지 말것인지를 설정해주는 속성이다.
     true(default임): 클라이언트가 사용할 별도의 고유 세션 영역을 할당해달라는 것이라는 설정 셋팅값이 된다. 
     첫 요청을 받았을 때 클라이언트가 사용할 고유영역을 할당해주는 것이 일반적임 (상태정보와 데이터를 공유하기 위함)
     false: 첫 페이지 요청 시 세션 영역을 할당하지 않음
     
     page디렉티브 info속성은 현재 jsp페이지의 정보를 주석처럼 달아줄 수 있는 용도이다.(거의 사용을 안함.) --%>
	
<%@ page session="true" %> <!-- 톰캣이 이 코드를 만나는 순간 고유세션ID를 생성해주게 된다. -->
<%@ page import="java.util.Date" %>
<%@ page import="java.text.SimpleDateFormat" %>

<%
	Date time = new Date(); //자바의 시간정보(국제표준시 형태 -> 직관적이지 않음)를 제공해주는 자료형 메모리 할당 
	SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); 
	//SimpleDateFormat의 메모리를 할당하면서 출력하고 싶은 형태를 입력포맷으로 지정 (날짜와 시간의 출력포맷을 셋팅한 것): HH - 24시간 표현법 / mm - 분 / ss - 초
%>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>세션 정보</title>
</head>
<body>
	
	세션 ID : <%= session.getId() %><br> <%-- session객체의 getId()메소드: 지금 고유하게 생성된 세션 ID를 다이렉트로 확인(실시간적으로 확인) --%>
	
	<%-- time.setTime: 입력으로 넣어주는 시간으로 time을 시작 시간으로 셋팅을 해주게 되는 메소드이다. 
	     getCreationTime()메서드를 이용하면 지금 막 세션을 할당한 시간정보를 반환해준다.
	     
	     지금 막 세션이 생성되어진 시간을 땡겨와서 time시간으로 고정을 시킨 다음에 이 시간을 확인해보도록 한다. --%>
	<% time.setTime(session.getCreationTime()); %>
	세션 생성 시간 : <%= formatter.format(time) %><br> <%-- 현재 생성된 세션의 시간을 내가 포맷을 지정한 형태로 확인할 수 있는 코드 --%>
	
	<% time.setTime(session.getLastAccessedTime()); %> <%-- getLastAccessedTime메소드: 가장 최근에 접근한 시간에 대한 정보를 얻어와준다. 
	                                                        ex)은행권 사이트에서 최근 접속 시간을 인폼으로 보여주는 기능이 있는데 
	                                                           그 기능이 getLastAccessedTime메서드를 사용한 것이다. --%>
	최근 접근 시간 : <%= formatter.format(time) %><br>

	<%-- 브라우저 종료버튼을 눌렀을 때만 고유세션을 소멸시킬 수 있는가? 그렇지 않다.
	     getMaxInactiveInterval()메소드: 여기에 셋팅되어져 있는 값을 읽어오는 것임 즉, 세션의 최대허용시간 읽어오는 기능. (초단위로 읽어올 수 있음)
	     ex) 은행권 사이트에 접속하여 로그아웃하지 않고 가만히 유지하고 있으면 30분이라는 제한시간을 둠 
	         브라우저에서 추가적인 요청이 없으면 30분 뒤에는 자동으로 세션을 소멸시켜버리는 것임. 
	         개인적인 보안 정책에 일환으로 별도의 로그아웃 요청을 하지 않더라도 30분동안 아무런 요청이 없으면 자동으로 세션을 소멸시킴으로해서 로그인에 대한 정보를 지우도록 한다. --%>
	세션 유지 시간 읽어오기 :
	<%= session.getMaxInactiveInterval() %> <%-- 30분(default의 세션 유지 시간이다.) --%>
	
	<%-- 30분이라는 세션 유지시간을 변경하고자 할 때, setMaxInactiveInterval활용한다.
	     세션의 유지되는 시간을 셋팅하는 메소드이다. (시간단위는 초이다.)
         
         아무런 요청을 추가적으로 하지 않으면 마지막 요청부터 10분동안 별다른 액션이 없으면 자동 로그아웃 되어지는 셋팅을 메서드를 통해서 수행하도록 함  --%>
	<%-- 세션 유지 시간 설정:
	<%= session.setMaxInactiveInterval(600) %> 10분 --%>
	<!-- 디폴트 30분 처리에 대한 셋팅에서 강제로 10분으로 셋팅을 해주고 있기 때문에 에러가 나고 있는 것임.
		 (이미 위에서[time.setTime(session.getCreationTime());] 시간을 셋팅한 상태이기 때문에 아래에서 세션 유지시간을 셋팅해서 에러가 나는 것임.)
		 
	web.xml을 활용하면 세션의 유지시간 자체를 범용적으로 셋팅할 수 있게끔 처리할 수 있음 (프로젝트의 모든 웹페이지의 세션의 유지 셋팅 값이 됨)
	session-config에서 자식의 session-timeout앨리먼트를 활용하도록 한다. => 분단위로 설정을 해줘야 한다. -->

</body>
</html>



<%-- 
[세션]
네트워크를 통한 통신 방식 중에 http프로토콜방식을 이용한 웹프로그래밍을 살펴보는 것임
: 웹브라우저라고 하는 응용프로그램에서 네트워크만 연결되어져 있다면 통신을 할 수 있는 방식
http프로토콜방식의 특징이 클라이언트의 요청 정보에 대해 서버가 응답을 보내오면 연결을 끊음 
-> 서버와 클라이언트간의 상태정보에 관한 정보를 서로 공유하는 부분에 대한 문제점이 발생!!
이에 대해서 나온 기술이 쿠키와 세션의 개념의 나옴 (어디에 보관할지가 차이점)
즉, 목적은 클라이언트와 서버간의 서로 상태에 대한 정보를 공유할 목적이라는 것이다.
차이점은 서로간의 상태에 대한 정보를 공유하기 위해서 생성한 데이터를 어디에 보관할 것인지의 부분이다.


쿠키: 생성은 서버가 하되 서버가 생성된 정보를 클라이언트에 응답을 보내면서 헤더에 생성한 쿠키정보를 담아서 클라이언트에 전송
브라우저는 그 정보를 받아서 쿠키의 저장소라는 공간에다가 서버로부터 전달받은 데이터를 보관하게끔 처리가 되어진다.
상대적으로 일반 클라이언트의 pc들은 보안에 있어서 취약함 -> 그러다 보니 민감한 정보들은 노출이 될 가능성이 크다.
그래서 쿠키를 이용해서 서비스를 하는 웹사이트들은 대부분이 쿠키정보를 암호화하여 처리하는 것이 일반적임. 
(암호화의 기술 또한 또 하나의 절차를 거치게 되는 과정임. 암호화의 기술을 별도로 가지고 있거나 암호화서비스와 연동해서 처리해야하는 번거로운 작업들이 필요함.)


그러다 보니 상대적으로 보안성에서 좀 더 뛰어난 클라이언트와 서버간의 상태 정보를 
공유하기 위한 이 데이터를 서버에서 관리하자고 하는 세션 처리 방법이 된다.
- 브라우저를 띄워서 응답을 받는 과정 속에 브라우저가 종료 버튼을 눌러서 종료할 때까지 종료되기 직전까지의 상태를 세션이라고 불러주고 있다.
  세션이라는 용어 자체는 기본객체(사용의 빈도가 높음)에서도 살펴봤었음 (+ 메모리 영역 - session) 

쿠키(클라이언트 영역에 보관)는 통신 프로토콜 방식에 따라서 클라이언트에서 생성할 수 있고, 서버에서도 생성할 수 있음
***jsp라는 기술 자체에서는 서버만이 쿠키를 생성할 수 있게끔 제공을 해주고 있었음. 
대부분의 기술은 쿠키를 서버에서 생성되어지도록 서비스가 되어지고 있음 -> 쿠키도 서버에서 생성한다고 생각해도 지장없음
 => 헷갈렸던 부분!) 쿠키를 어느 시점에 요청할 때 서버로 전달할지에 대해서는 도메인과 path에 대한 설정을 통해 처리할 수 있었음
 => 쿠키정보가 가장많이 활용 되어지는 기능: 로그인,아웃 관련된 상태에 대한 정보 공유 (실제 사이트에서는 암호화를 하여 처리되어야 함.)


!!생성한 공유 데이터를 어디에 보관하는지에 따라서 쿠키와 세션으로 나뉨!!
세션은 서버영역에 데이터를 보관하는 기술이다. 기본 내장 객체와 영역에서 세션의 이름이 있었음. 
       클라이언트와 서버간에 상태 정보를 공유하고자할 때 상태 정보를 공유하기 위해서 발생한 데이터를 scope(영역)에 보관을 하도록 한다.      
       세션영역에 접근하는 방법은 기존 영역 실습과 동일함. (session객체를 통해서 setAttribute, getAttribute메서드들을 활용)  
       
       웹컨테이너: 웹서비스에서의 뭔가를 적재하는 것으로 보관영역을 생각
       세션은 웹컨테이너에서 클라이언트의 정보를 보관할 때 사용하는 적재(보관)장소인 것이다. => 오직 서버에서만 데이터를 보관할 수 있는 세션을 생성할 수 있다.
       ex) 구글 서버에서 검색 -> 검색한 결과를 화면으로 출력
       구글 서버의 입장에서는 최초 요청 시에 클라이언트가 사용할 고유 세션의 영역을 할당해준다.
       서로 다른 클라이언트마다 크롬의 첫 페이지에서 검색을 해서 최초 요청을 하는 순간 
       응답 시에 지금 클라이언트가 사용할 고유 세션을 할당해주게 된다.
       ***두 번째 누군가가 또 웹페이지를 요청을 하게 될 때도 고유 세션 메모리 영역을 할당해주게 되는 것이다.(별도로 세션이 할당된다고 기억!!)
       
       
       최초 구글에 웹페이지를 요청하면 내가 사용할 내 고유영역에 세션을 구글이 별도로 할당을 해주는 것임.
       접속을 할 때마다 클라이언트들이 고유하게 사용할 수 있는 고유 세션 영역을 할당해서 서로 독립적인 메모리 공간을 할당하여 사용하게끔 처리가 되어지는 것임

       http프로토콜 방식은 최초 요청이오고 응답을 보내면 연결을 끊음. 
       그렇다면 쿠키 정보를 별도로 생성을 해준 것이 아닌데 클라이언트가 다시 요청을 해올 때, 고유하게 할당되어진 세션 영역을 어떻게 구분하여 판단할 수 있는가?
       (이전에 요청을 해온 사람이 요청을 해온 공유 정보인지 세션 영역에서 어떻게 구분하는 것일까?)
       02_viewCookies.jsp실습 => 클라이언트가 요청(쿠키정보를 전부 꺼내오게끔 요청)한다고 가정 -> 텍스트단위로 읽으면서 전송
                                 -> 전송을 하면서 실시간적으로 실행되어질 것임 -> 현재 실행을 하면 쿠키 정보가 없음(최초 요청이기 때문.)
                                 한번 더 새로고침을 하면 JSESSIONID가 생김
       
       주의!! 생각해놓기!!)최초 브라우저를 띄워서 최초 요청을 특정페이지에 하게 되면 서버에서는 우리의 의지와는 상관없이 서버가 자체적으로 
                           JSESSIONID라고 하는 16진수의 번호를 쿠키로 생성하여 클라이언트에게 재요청이 왔을 때 전달을 해주게 된다.
       
       
       JSESSIONID의 용도는 최초요청을 해오면 서버는 요청해온 클라이언트만이 사용할 세션영역을 할당
       -> 할당되어진 영역을 클라이언트가 요청을 해올 때마다 서버가 체크할 용도(누구한테 할당된 영역인지의 체크 용도)로 
          이 세션의 고유 ID이름을 붙이고 쿠키로 생성하여 응답으로 보낼 때 같이 정보를 보내주게 되는 것이다.
       그래서 새로고침을 하게 되면 똑같은 페이지를 요청했음에도 세션ID가 생성되는 것이다. (영역에 고유이름을 붙여놓은 것이다.)
       
       세션ID를 통해 고유영역을 구분하게 되는 것. 한 번 브라우저를 실행하고 난 다음 부터는 세션의 고유 번호를 유지하고 있는다.
       현재의 브라우저에서 브라우저를 새롭게 띄웠다고 하더라도 세션의 고유 ID를 보면 동일한 번호로 유지된다. (서버입장에서는 동일한 클라이언트이기 때문)
       
       언제 소멸되느냐? 전체적으로 브라우저를 종료했을 때.
       쿠키도 유지시간을 별도로 지정하지 않으면 디폴트로 브라우저를 종료했을 때까지 쿠키정보를 보관하도록 한다. 
       그렇기 때문에 세션ID도 서버에서 만들어서 응답으로 보낼 때 디폴트로 보내게 됨 -> 그렇기 때문에 브라우저가 종료되면 쿠키도 삭제될 것임      
       로그인을 한 다음에 브라우저를 다 종료하고 새롭게 브라우저를 띄우면 로그아웃이 자동처리가 되어 다시 로그인을 해야하는 상황을 확인할 수 있다.
                                
       웹서비스 초창기에는 쿠키의 정보를 일정시간동안 유지하도록, 아니면 삭제가 안되도록 반영구적으로 유지되도록 서비스하는 웹사이트가 있었음
       설사 브라우저가 종료되더라도 쿠키저장소에는 ID가 보관되기 때문에 서버는 로그인된 상태로 생각함. (2000년대 이전까지는 상당히 많았음)
       일반 PC나 공용PC같은 경우 로그아웃을 하지 않으면 다른 사람이 웹사이트를 접속하면 로그아웃이 되지 않은 상태인 경우가 비일비재였음. 그래서 보안상에 상당한 문제점이 야기됨.
       따라서 개인정보에 민감한 서비스일 경우에는 쿠키와 관련해서는 디폴트로 셋팅해서 브라우저가 종료되면 자동적으로 쿠키정보도 삭제가 되게끔 반드시 서비스를 해줘야 한다. 
       지금은 개인정보에 상당히 민감하다보니까 악의적인 쿠키를 생성해서 정보를 도용하는 사례들이 많이 발생 -> 그러한 부분들에 대해서 웹사이트를 구축할 때 염두하도록 해야한다.
       
       이전 개념에는 클라이언트마다의 고유 할당되어지는 메모리의 크기가 공통적으로 
       서버 자체적으로 브라우저 종료전까지는 서로 공유 메모리 공간을 별도로 할당을 해주고 있지만
       서비스를 받는 입장에서는 메모리의 할당 부분을 느끼지 못하는 것이다.
       
       세션의 실습해서는 프로젝트를 동일한 프로젝트에서 결과에 대한 처리를 수행을 해야 정보가 일치되어지는 결과를 확인할 수 있음
       아예 다른 프로젝트로 실행을 하게 되면 정보에 대한 ID가 개별적으로 실행되어지는 프로젝트의 차이점으로 보여지고 있을 뿐이다.
       ***프로젝트에 따라서 세션ID가 다를 수 있음!! (지금 현재 실행했을 때의 세션ID와 chap09/02_viewCookies.jsp실습파일의 세션ID가 다름.)
          서버입장에서는 프로젝트의 단위로 실행을 하게 되면 별개의 프로젝트로 인식이 되어지기 때문에 세션ID도 따로 생성이 되어지는 것이다.
          
--%>