package net.board.action;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import net.board.service.BoardAddAction;
import net.board.service.BoardDeleteAction;
import net.board.service.BoardDeleteView;
import net.board.service.BoardDetailAction;
import net.board.service.BoardListAction;
import net.board.service.BoardReplyAction;
import net.board.service.BoardReplyView;
import net.board.service.BoardUpdateAction;
import net.board.service.BoardUpdateView;




@WebServlet("*.bo") //앞에 무엇이 오든 상관없이 끝나는 뒤에가 .bo(게시판관련된기능)로 끝나는 요청이기만 하면 내 서블릿에서 다 처리하겠다는 의미이다. 
public class BoardFrontController extends HttpServlet {
	private static final long serialVersionUID = 1L;
	
	//브라우저에 사용자로부터 전달받은 정보를 노출시킬 것인지의 여부 때문에 전송방식을 두 가지로 나뉘게 된 것이다.
	//요청을 받은 서버입장에서는 get방식이든 post방식이든 처리되는 동작에서 구별을 할 이유가 없음. (톰캣입장에서는 똑같음. 단지 post방식에서 한글이 깨지지 않게끔 인코딩을 지정하는 것만 다를뿐.)
	//=> get방식일 때는 브라우저상에 쿼리문자열로 담겨서 전송이 되어짐. 브라우저에서 전송이 되어질 때 이미 인코딩의 방식을 거쳐서 전송이 되어져 오고, 톰캣은 디코딩의 과정으로 파라미터의 값을 꺼내옴
	//   몸체에 담겨져 올 때는 인코딩과 디코딩의 과정이 없음. post방식은 몸체에 담겨져 전송이 되어지기 때문에 톰캣이 파라미터 값을 꺼내올 때는 텍스트는 utf-8포맷으로 꺼내오라는 환경에 대한 설정을 꼭 해줘야 하는 것이다.
	/* @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//System.out.println("doGet() 호출.");
		doProcess(request, response); //request와 response를 다시 전달하는 것임.
	}

	/* @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//System.out.println("doPost() 호출.");
		doProcess(request, response);
	}
	
	
	
	
	
	//get방식이든 post방식이든 이 doProcess메소드를 공통적으로 호출하여 하나로 처리하고자 하는 것이다.	=> CRUD와 같은 기능들을 이 메소드 안에서 다 처리를 하면 된다.
	//.bo로 요청이 오면 다 이 메소드를 호출하려고 할텐데, 그에 대한 기능을 구분되어야 할 것이다. => 어떤 기능인지에 대한 정보를 알아야 한다.
	protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//.bo 앞에 있는 클라이언트가 요청하는 정보를 알고 싶은 것이 목적이기 때문에 (클라이언트의 모든 정보를 request객체에 담아서 전달)
		//request객체의 getRequestURI메소드를 활용하도록 한다. => 포트번호 이후로부터의 모든 정보를 반환해줌.
		String requestURI = request.getRequestURI();   // 이 메소드는 /chap15_Board/BoardWrite.bo를 반환해줄 것이다.
		System.out.println("URI : " + requestURI);
		String contextPath = request.getContextPath(); // 이 메소드는 /chap15_Board를 반환해줄 것이다. (프로젝트 이름 반환하는 것임.)
		System.out.println("path : " + contextPath);
		
		String command = requestURI.substring(contextPath.length()); //substring메소드: 인덱스값을 넣어주면 인덱스의 이후부터의 문자열을 꺼내와서 값을 반환해주게 된다.
		//실질적인 클라이언트의 요청사항을 파싱(꺼내오는 것)하는 것이다.(서블릿에 첫번째 주요 기능!! -> 어떤 요청을 해온 것인지에 대한) => BoardWrite.bo부분만 가져오도록 하는 것!!
		//이후, 파싱한 정보를 통해 DB와의 연동을 하는 것까지의 구성이 되어야 한다.
		System.out.println("command : " + command); // command : /BoardWrite.bo반환 => 사용자의 요청정보가 담긴 것임.
		
		//getRequestURI에서는 그 뒤에 붙는 파라미터의 값은 추출해오지 않는다. => /chap15_Board/BoardDetailAction.bo의 값이 출력됨
		
		
		Action action = null; //서비스단의 참조변수를 선언 => execute메소드 호출목적
		ActionForward forward = null; //포워드할지, 리다이렉트할지에 대한 정보를 담을 참조변수를 선언
		
		
		//command에 담긴 데이터가 전달한 내용과 동일한지 확인하는 조건문 
		if(command.equals("/BoardWrite.bo")) { //글쓰기 폼(별도로 DB와 작업할 필요없이 보여줄 화면을 바로 forward하면 됨.)
			forward = new ActionForward();
			forward.setPath("./board/qna_board_write.jsp"); //이동해갈 페이지의 위치 경로
			forward.setRedirect(false); //redirect를 할 것인지를 확인하는 필드로써 forward를 할 것이기 때문에 false를 넣어주면서 구별시킴.
				
			
			
		//추가할 기능들은 수정, 삭제, 한게시물의 상세 목록등등 => 기능이 확장될 때마다 else if문을 통해 추가해가면 됨	
		}else if(command.equals("/BoardAddAction.bo")) { //폼에 작성된 내용이 전달됨.
		//데이터를 꺼내와서 꺼내온 데이터를 DB에 저장해주는 비즈니스 로직을 작성해줘야 한다. => DB에 저장할 테이블부터 만들어줘야함.	
			//System.out.println("==> /BoardAddAction.bo");
			
			//DB와 연동하려면 자바빈(데이터를 처리할 모델)을 먼저 만들어야 함 (이 자바빈과 board테이블이 연동하여 같이 동작시킬 목적) 
			//자바빈에 데이터를 꺼내와서 저장 -> 최종적으로 DB에 데이터 저장 (자바빈은 테이블과 함께 동작함)
			//즉, 자바빈을 먼저 정의 -> 전체적인 구조(틀)부터 만들어놓기 -> CRUD의 기능이 정의되어져 있는 CAO를 정의하는 것이 다음 단계임
			action = new BoardAddAction(); //메모리를 먼저 할당, 이 자료형 안에 execute메소드를 호출할 목적임. 
			forward = action.execute(request, response); //***execute가 실행되면 시작주소값을 가지고 리턴되어서 올 것임. -> 화면전달에 정보가 담긴 인스턴스의 시작 주소 값을 forward에 담음
			
			//위에 데이터를 DB에 삽입하는 기능 이외에도 읽어오기 ,수정, 삭제의 기능들이 있는데 그 기능들이 다형성에 의한 오버라이딩 구조를 가지면
			//지금 작성한 코드를 그대로 가져가면서 new의 대상만 바꿔주면 된다. CRUD의 모든 기능을 전부 Action으로만 바라보겠다는 것이다. 
			//이렇게 작성된 상속에 의한 다형성의 구조는 코드의 구현과 가독성이 높아지는 큰 장점을 가지게 된다.
			
			
		
		}else if(command.equals("/BoardList.bo")) { //게시글의 목록 보기(전체목록) => DB에 담긴 내용들을 가져와야 하기 때문에 DB와 꼭 연동되어야 함.
		//이러한 구조로 잡게 되면 list의 요청을 Add와 동일하게 코드를 잡아주고, 다형성에 의한 메소드를 오버라이딩하여 각 기능들을 호출할 수 있도록 한다.	
			action = new BoardListAction();
			forward = action.execute(request, response); //리스트에서도 동일하게 화면의 전송 방식에 대한 구조를 잡아주도록 한다.
			
			
			
		}else if(command.equals("/BoardDetailAction.bo")) { //상세페이지 화면 보기
			action = new BoardDetailAction();
			forward = action.execute(request, response);
		
		
		}else if(command.equals("/BoardReplyView.bo")) { //댓글을 달 수 있는 화면 보기 (DB와 연동구조임. 어떤 글에 대한 댓글이라는 최소의 정보를 담아서 화면상에 보여줘야 하기 때문)
			action = new BoardReplyView();
			forward = action.execute(request, response);
		
		
		}else if(command.equals("/BoardReplyAction.bo")) { //댓글을 달았을 때의 이벤트를 구현하도록 한다.(서버에 입력된 데이터 전달.)
			action = new BoardReplyAction();
			forward = action.execute(request, response);
			
			
		}else if(command.equals("/BoardDownload.bo")) { //DB와 전혀 상관이 없기 때문에 폼만 보내도록 한다. => 서비스단으로 넘길 필요가 없음. 이동해갈 페이지 정보만 넘기면 됨
			forward = new ActionForward();
			forward.setPath("./board/qna_board_download.jsp");  
			forward.setRedirect(false);
		}
		
		else if(command.equals("/BoardUpdateView.bo")) {  //수정에서 보여줄 화면
			action = new BoardUpdateView();
			forward = action.execute(request, response);
		}
		
		else if(command.equals("/BoardUpdateAction.bo")) {  //수정을 하면서 액션을 취할 페이지
			action = new BoardUpdateAction();
			forward = action.execute(request, response);
		}
		
		else if(command.equals("/BoardDeleteView.bo")) {  //삭제하기
			action = new BoardDeleteView();
			forward = action.execute(request, response);
		}
		
		else if(command.equals("/BoardDeleteAction.bo")) {  //삭제하기
			action = new BoardDeleteAction();
			forward = action.execute(request, response);
		}
		
		
		
		
		/* 실제 실무에서 서비스되어지는 웹사이트들은 두 종류가 있음. 
		   index.jsp페이지를 만들어서 forward하는 방식이 있고, 다시 sendRedirect하면서 다시 화면을 재요청하면서 서비스할 수 있는 방법이 있음
		   도메인 이름을 치고 들어갔을 때, 도메인 이름만 보이면 forward로 구현된 기술이고, 
		   프로젝트 이름만을 넣었는데 url뒤에 뭔가가 추가되어져서 처리가 되어진다면 sendRedirect로 구현된 것으로 생각하면 됨
		   sendRedirect의 특징은 응답을 보내면서 다시 브라우저가 서버로 요청하게끔 처리하는 방식이기 때문에 요청 정보가 그대로 쿼리문에 노출이 되어지는 것이였음.
		   forward는 서버가 자체적으로 특정 jsp로 이동해서 응답으로 보내는 서비스이기 때문에 클라이언트 입장에서는 url상에 전혀 변화가 없음. */
		
		
		//***실질적인 요청이 왔을 때 바로 화면을 보내주면 되는지, DB와 연동한 후에 그 응답을 담아서 보내줄 것인지
		//응답을 보내주는 시점에 forward가 아닌 sendRedirect에 의한 화면을 재요청해서 응답을 보내줄 것인가에 시퀀스를 가져가는 것이 게시판에서의 다임. 
		//웹어플리케이션의 구현 종류(2가지) => View화면 자체를 forward하여 응답, sendRedirect를 하여 서버에 화면을 재요청을 하면서 응답
		//거의 모든 웹어플리케이션은 둘 중에 하나가 컨셉이기 때문에 공통적으로 처리하기 위해 기능을 모듈화시키도록 한다. 
		//(반복코드를 만들지 않을 목적으로 컨트롤러에서 일괄적으로 처리하려는 코드인 것이다.)
		if(forward != null) { //null이 아닐 경우에만 처리를 하도록 한다.
			if(forward.isRedirect()) { //지금의 요청이 sendRedirect를 할 것인지 forward를 할 것인지를 체크하는 조건문이다. (false를 하면 forward를 처리하는 것임. true면 sendRedirect 처리.)
				
				//웹어플리케이션은 응답으로 화면을 보여줘야 하는데 등록에 관련된 리스트의 화면이 응답으로 가게끔 처리해주는 것이 가장 일반적인 프로세스이다.
				//리스트화면으로의 응답 서비스는 아주 빈번하게 사용이 되어진다.(삭제한 후 리스트 화면 응답, 수정한 후에 리스트 화면 응답, 글을 등록한 후 리스트 화면 응답 등등)
				//수행이 끝나고 난 다음에는 리스트에 대한 화면 응답요청을 다시 브라우저에 요청하게끔 처리를 한다면 (기능마다 리스트화면을 별도로 생성 X)
				//얼마든지 하나의 기능이 완성되어있을 때 이 기능을 계속해서 호출하면서 재사용이 가능할 것이다. 이러한 용도로 사용하는 것이 response의 sendRedirect인 것이다.
				//즉, 기능만 구현이 되어져 있다면 언제든지 어떤 동작이 끝나든 간에 response의 sendRedirect를 통해서 동일한 화면을 요청하도록 하면 됨.
				response.sendRedirect(forward.getPath()); 
				//response객체의 sendRedirect메소드는 요청을 다시 보내게끔해서 브라우저쪽으로 다시 화면을 보내올 것이다.
				//리스트의 화면만 잘 구현한다면 최종적으로 화면이 잘 보여지는진다는 것을 결과화면으로 확인할 수 있음.
				// ***'/'는 빼고 넣어주도록 해야 프로젝트 이름 밑에 최하위로 요청을 하게 된다.
				
			}else {	
				//글쓰기 양식을 화면으로 보내줘야 함. (DB와 연동할 필요없음. 양식이기 때문)	=> 서블릿에서 어떻게 jsp로 이동해서 이 jsp페이지를 클라이언트에게 보내줄 수 있는지가 포인트
				//getRequestDispatcher메소드: 이동해가서 서비스하고 싶은 페이지에 대한 정보를 입력으로 넣어주면 된다. (최종적으로 서비스할 페이지에 대한 정보를 경로와 함께 전달)
				//                            메소드를 통해서 호출을 해오면 이 메소드안에 의존적인 클래스가 정의되어 있어서 자체적으로 new해서 메모리를 할당하여 
				//                            필요한 데이터들을 그 메모리에 보관하고 시작주소값을 반환해주는 형식으로 객체를 반환한다.
				//RequestDispatcher안에 forward라는 메소드가 구현되어져 있음. => 이 forward는 액션태그를 생각하도록 한다.
				//=> 서블릿에서 getRequestDispatcher메소드를 호출하면서 입력으로 전달한 정보를 보고 해당페이지로 이동해가게끔 제공해주는 기능이다.
				
				RequestDispatcher dispather = request.getRequestDispatcher(forward.getPath()); //내가 응답으로 보낸 페이지의 정보를 가진 객체가 된다.			
				dispather.forward(request, response);  //지정한 페이지로 이동하고 jsp를 읽어가면서 클라이언트 브라우저로 전송이 되어지는 것임.
				//jsp의 forward액션태그(if문을 통해 이동해갈 주소를 넣어줬었고, 조건에 따라 페이지로 이동했음)와 동일, 다이렉트 이동 
				// => 즉, forward()메소드는 페이지 이동과 관련된 기능을 제공해주는 메소드임. (서블릿을 통해 jsp를 적용하는 방법!!)
			}
		}
			
	}
	
	
}




//[!!과제!!]
//DB에 저장한 비밀번호와 지금 입력한 비밀번호가 동일할 때에만 삭제되도록 하자.(틀리면 비밀번호확인이라는 조치가 필요) => 리스트화면 띄우기 sendredirect를 통해 처리(잘 삭제가 되어졌는지 확인되도록 함)
//수정도 작성한 사람만 할 수 있어야함. 따라서 UI창에 비밀번호가 추가되어야 함. 비밀번호와 수정하려는 레코드 데이터가 일치해야 수정되도록 한다. (수정이 되면 수정된 화면을 보여주도록 한다.)





/*  
파싱된 어떤 요청인지 판단했을 때 최종적으로 데이터베이스에 저장을 하겠다라고 한다면 실질적으로 서블릿은 CRUD를 처리하는 기능으로 정의하지는 않는다. 
(일반적으로 서블릿은 파싱의 기능까지만 담당한다!!)
DB까지 연동하여 처리하는 다음단계의 구조는 어떻게 가져가야 하느냐? 
파싱의 1단계, DB와 관련하여 그 요청정보를 보고 실질적인 클라이언트의 요청사항을 처리하는 처리레이어, 이 처리레이어를 일반적으로 서비스레이어라고 부른다.
요청사항을 파싱한 후 바로 jsp페이지를 응답으로 보내줬음. user의 화면을 바로 서비스하는 레이어라고 하여 프리젠테이션레이어라고 한다.
=> 사용자 요청에 따라 바로 파싱하여 페이지 전달. (응답에 최선을 다함. 클라이언트의 요청사항을 정확하게 파싱해서 알려주는 것이 역할임)	

그 요청사항이 DB와 연동하여 작업을 해야하는 요청이라고 한다면 그 요청을 실질적으로 처리하는 레이어를 서비스레이어라고 불러준다.
이 서비스레이어에서 실질적으로는 클라이언트가 보내온 데이터를 꺼냄. 꺼내온 데이터를 최종적으로 DB에 저장!!
=> 글을 등록하는 것이 클라이언트의 요구사항이고 이 부분을 서비스레이어에서 구현해주는 것이다.
   만약 글을 읽어달라는 select요청일 때도 DB와 관련이 있는 요청이기 때문에 서비스레이어에 알려주게 되는 것이고,
   서비스레이어가 DB에서 데이터를 가지고 와서 화면을 응답으로 보내주게 되는 것이다.
=> 사용자의 요청사항을 실질적인 처리를 수행하는 이처리를 하는 백엔드단의 기술에서 
   클라이언트의 작업을 실제 수행하는 레이어라고 하여 범용적으로 비즈니스로직(비즈니스레이어)이라고도 부른다.
실질적으로 코드를 구성할 때는 서비스라는 용어를 많이 사용하고, 레이어로 얘기할 때는 프리젠테이션 레이어, 비스니스 레이어라고 얘기한다. 

jdbc에서는 자바빈은 VO, DTO라는 이름을 붙여서 클래스를 정의했고, 실질적인 CRUD의 기능은 DAO라는 이름을 붙여서 클래스를 정의를 했었다.
DAO로 실질적인 데이터베이스와 작업하게끔 정의되는 이 클래스가 포함되는 레이어는 데이터를 영구적으로 보관한다.
내가 삭제하기 전까지는 데이터를 영구적으로 보관하는 것임. 이 레이어는 repository, persistence(연속적이고, 반영구적인)라고 혼용하여 불러주고 있다.
=> 3개의 레이어구조로 구성을 해주고 있는 것이다!! (프레젠테이션레이어, 비즈니스레이어, 퍼시스턴스레이어)

뭔가 화면이 띄워진 상태에서 띄워진 메뉴화면에 번호를 눌러서 만약 데이터를 저장하겠다고 한다면 저장하는 DAO만 호출을 하면 될 것이라고 생각할 수도 있다.

쇼핑몰을 생각해보면 이 DB에는 회원에 관한 테이블, 게시판에 내용을 저장할 테이블, 상품 목록 테이블등의 테이블이 필요할 것이다.
기능에 따라서 아주 많은 데이터를 관리해야 하므로 그 관리되는 데이터만큼 테이블이 추가가 되어질 것이다.
그리고 그때마다 각각의 데이터를 CRUD할 수 있는 DAO가 하나씩 같이 자바빈과 함께 연결되는 구조로 persistence영역에 레이어가 구성이 될 것이다.
즉, persistence영역에 레이어는 테이블 하나당 DAO가 하나씩 구성이 돼서 그 DAO는 서로 독립적인 동작이 되게끔 설계가 되어져야 하는 것이다. (DAO가 하나만 구성된다면 기능이 폭파할 수 있음 -> 코드 전체를 들여다봐야함. 관리가 어려움)
하나의 테이블당 하나의 DAO가 구성을 하여 최적화되어지게끔 모듈화가 되어야 나중에 변경사항이 있어도 그 모듈만 들여다보고 수정을 할 수 있게끔 구성을 해주는 것이 좋다.

그러다보니 회원관리용DAO, 상품관리용DAO 별도로 설계가 되어질 것이다.
지금 현재 쇼핑몰에 기존 쇼핑몰에서는 상품을 클릭해서 구매하는 구매정보들이 잘 서비스가 되어지고 있었음.
이 사이트들이 매출을 올리겠다고 할인 특가, 보너스 증정이라는 이벤트를 진행. 기존에는 a상품을 구매자가 구매를 하겠다고 요청을 하면 구매에 대한 처리만 하면 됐었는데
이 구매를 했을 때 보너스 1000점을 드리겠다고 했다면 보너스에 대한 정보는 개인이 가지고 있는 또 다른 테이블에서 데이터들이 관리가 되어질 수 있다.
그럴 경우라면 요청을 받았을 때 상품처리에 기존에 처리를 수행하고, 추가적으로 포인트라는 점수를 다시 그 데이터에 추가를 해줘야 하는 것임.

프리젠테이션 레이어는 응답에 최선을 다하고 클라이언트의 요청을 정확하게 파악해서 알려주라는게 임무인데 이미 그 임무만으로도 벅참
요청파악과 파악한 요청을 기반으로 로직까지 구현을 해야한다면 얘의 역할이 너무 광범위해짐. 따라서 이 역할을 비즈니스로직의 서비스에게 넘기라는 것이다.
그래서 서비스에서 요청만 받으면 이 요청은 상품도 구매하고 거기에 보너스 데이터도 업데이트하라는 것을 파악하고 
요청하고 오면 다음명령으로 보너스 점수를 업데이트하고 다시 올 수 있게끔 서비스에서 처리를 하는 것이다.
즉, 어떤 요청인지만 전달받고 전달받은 요청의 실질적인 로직(기능)은 서비스에서 처리하라는 것이다.
DAO에 저장하고 와서 끝나는 것이 아니라 그 상품에 대한 개인들마다 포인트점수를 따로 관리하게끔 테이블이 추가되어져 있다면 그 테이블에 가서 포인트를 추가해주게 됨

repository레이어에서는 테이블마다 DAO가 준비되어져 있고 그 DAO를 매니지먼트하는 역할을 서비스가 하게끔 구조를 잡으라고 하는 용도인 것이다.

지금 구성한 서블릿은 순수 파싱과 그에 대한 화면 응답에 대한 부분에만 최적화되게끔 기능을 구현하는 것이다.
나머지 요청에 대한 정보는 비즈니스로직에 해당하는 서비스라는 레이어를 구성할 것이고,
그 구성된 레이어를 바탕으로 우리가 만들어놓은 자바빈과 DAO를 서비스해서 내니지먼팅해서 최종적인 결과가 나오면
그것을 화면에 실어서 응답으로 보내주려고 하는 것이다.

프리젠테이션 레이어(클라이언트의 요청사항과 서비스할 화면에 충실하자는 기능), 
비즈니스로직에 해당하는 서비스 레이어, 데이터를 반영구적으로 저장할 persistence의 repository레이어,
DTO, V0라고 하는 자바빈을 정의해서 데이터베이스에 정의된 테이블과 매칭시킬 수 있는 자바빈을 정의해서 
이 자바빈과 테이블을 CRUD해주는 DAO를 persistence레이어에 구성하고 그 테이블마다 자바빈을 독립적으로 각각 연결되게끔 해준다면 
이 것들을 서로 매니지먼트해주는 것은 서비스에서 하도록 함.

테이블 만듦 -> 테이블에 매칭될 자바빈 만들기 -> 자바빈과 테이블을 연관지어줄 CRUD의 DAO를 구성 -> 서비스를 구성하면서 매니지먼트함. 
(이 부분이 MVC패턴에서의 백엔드단의 기능을 완성해가는 프로세서인 것이다.)

-------------------------------------------------------------------------------------------------------------------------------------------------

3/27(월) 

[게시판(지금까지 배운 내용들의 총 집약체/기본베이스)실습]
- 코드의 흐름에 대해 생각하면서 게시판 실습 반복 연습하기.

게시판의 기본적인 흐름
서버컴퓨터가 있고, 서버컴퓨터에게 클라이언트의 요청사항이 전달이 되어졌다고 한다면
기본적으로 게시판의 거의 모든 프로젝트와 공공기관같은 경우에는 표준으로 
모델2(MVC패턴)의 디자인 패턴의 기반 구조를 잡아서 진행을 하게 된다.

MVC는 모델, 뷰, 컨트롤러라고 하는 3개의 레이어로 구성을 해서 골격을 잡아줌 

Model: 데이터관점이라고 보면 됨 
       실질적으로 관리해야 할 데이터는 DB에 보관하는 것이 일반적임
       DB는 데이터를 테이블의 형태로 관리하게끔 정의되어져 있음(특징. 한 데이터가 레코드(행단위) 형태임.)
       프로그래밍언어에서 레코드단위로 데이터를 관리하는 것을 객체지향이라고 함(OOP)
       => 이전에는 기본자료형으로 데이터를 낱개단위로 데이터를 관리했음

데이터를 테이블 형태로 관리하는 OOP로 자바같은 경우 class로 참조자료형을 선언한다.
이때, 테이블과 매핑되는 참조자료형을 정의해서 프로그래밍 안에서 관리하도록 
선언하는 자료형을 자바빈이라고 한다. 
즉, 클래스를 정의할 때 데이터를 관리할 목적으로 정의하는 자료형이 자바빈이라고 불린다. 
- 자바빈의 규약: getter, setter메소드의 정의는 프로퍼티에 이름에 기반해서 
                정의가 되어져야 한다는 것이 규약, 약속이였음
프로퍼티의 이름은 프로그래머가 정의하면 되는데 이것저것 신경을 쓰지 않으려면 필드의 이름으로 매칭시키자.
=> 필드의 이름과 똑같이 프로퍼티 이름으로 정의를 한다면 이클립스를 통해 자동으로 get, set메소드 생성가능
이렇게 정의되어지는 클래스는 자바빈 규약을 따르고 있다고 하여 클래스 이름 뒤에 DTO, VO, Bean을 붙여서 정의한다.
=> 이러한 이름이 붙어 있으면 자료형의 코드를 분석하지 않더라고 
     테이블과 매핑하여 데이터 주고 받게끔 정의하고 있는 자료형이라고 생각하자.



자바빈 규약을 따르는 클래스를 정의한 이유는 데이터를 담아서 자바코드 안에서 처리를 한 다음에 
최종적으로 DB에 저장을 하거나 DB에 저장된 데이터를 꺼내와서 자바라는 코드 안에서 사용하기 위함이다.

CRUD의 기능이 DB와 연동하여 실질적으로 데이터를 처리할 작업들이다. 
Create(insert), Read(select), Update, Delete
CRUD를 정의하는 클래스는 DAO라는 이름을 붙여서 정의를 했었음
=> 자바빈 규약을 따르는 VO를 가지고, 테이블과 연동하면서 CRUD의 기능을 정의하는 클래스이다.

데이터에 access(접근)하는 객체라 하여 연속적으로 영구의 데이터를 보존하는 데이터베이스와의 작업이라고 하여 persistence레이어라고 불림.
그래서 이렇게 처리되도록 정의되는 파트를 repository기능이 구현되어져 있는 
persistence레이어라고 통칭해서 부른다.
이파트를 MVC파트의 데이터를 처리하는 [모델파트]의 부분이 된다.


코드상으로는 DB의 테이블과 매칭해서 데이터를 처리할 목적으로 정의한 자바빈 규약을 따르는 클래스와
자바빈 규약에 의해서 데이터를 실질적으로 저장하거나 담는 과정등의 처리를 위해 정의된 
DAO클래스로 구성이 되어지는 것이 일반적임 => 프로젝트 구성시 실질적으로 이 영역부터 구성하여 시작하게 됨.

이 파트를 자바와 DB시간에 자바 기술을 이용했을 때는 자바에서는 jdbc라는 로직으로 이 처리를 수행할 수 있게끔 라이브러리가 제공이 되어졌었음.
[실질적인 데이터가 저장된 로직이 첫번째 프로젝트 구성시 이 구조를 제일먼저 설계하고 구현하게 됨]

-------------------------------------------------------------------------------------------------------------------------------------------------

위 부분이 웹어플리케이션과 어울러지면서는 
웹이라할 때 서비스의 루틴이 클라이언트라는 PC가 브라우저를 통해서 요청을 하는데
jsp라는 기술이 http통신 프로토콜기반에 서비스 되어지는 프로그래밍이였음

이 시퀀스를 따라서는 클라이언트가 브라우저를 통해서 웹 페이지 요청이 전달 
-> 요청을 받은 서버가 톰캣이라는 프로그램을 사용하여 클라이언트 요청에 대한 응답을 보내줌
-> 그때 사용하고자하는 기술이 브라우저는 웹표준이라는 기술을 이용해서 서버가 보내온 응답을 화면을 통해 보여줌
그 화면은 서버에 구축이 되어져 있어서 요청이 왔을 때 해당 UI를 보여줄 페이지를 
응답으로 보내서 화면으로 보여지게끔 한다. 즉, 응답으로 보여줄 페이지는 서버에 미리 탑제되어져야 한다.
=>jsp의 기술을 통해 화면을 구현하도록 함.

MVC에 화면을 보여주는 View의 기능을 jsp의 기술을 활용하도록 한다.

(요청에 대한 종류는 두 가지 -> 뷰라는 화면만 응답으로 보낼지, 최종적인 DB와 연동해서 연동되어진 결과를 뷰에 담아서 응답으로 보내줄지)
웹표준에서는 특정화면은 DB의 데이터를 읽어와서 구성해야하거나
클라이언트가 보내온 데이터를 DB에 보관해야한다고 할 때 화면을 구성하는 웹표준에는 
DB와 연동하는 기술을 제공해주고 있지 않았음.
=> 웹표준과 어우러져서 DB와 연동할 수 있는 기술은 jsp, php, asp라는 기술이 있음
그 중에서 jsp가 무료로 모든 기술을 사용할 수 있게끔 제공을 해주고 있어서 
현재 대부분의 웹사이트들은 상대적으로 저작권 비용을 최소화할 수 있기 때문에 jsp를 적용.(2010년 이후)
-> jsp를 바탕으로한 스프링의 기술로 프로젝트를 진행하게끔 표준화함


현시점에서는 기능들이 다양해지고, 클라이언트의 요청이 다양해지고 많아지다 보니까
하나의 jsp페이지 안에 자바 코드와 웹표준이 같이 작업이 되어졌을 때는 많은 문제점을 야기됨

그래서 자바코드와 화면을 구성하는 웹표준의 코드를 최대한 분리시키는 개념에서 
클라이언트의 요청이 왔을 때 그 요청을 파악해서 이 요청이 단순히 화면만을 응답으로 보내주면되는지 
DB와 연동해서 처리를 수행하면 되는지에서 화면과 자바코드를 구별하는 이 처리를 
서블릿이라고 하는 기술을 적용하도록 한다.
=> 서블릿은 순수 자바코드로 웹프로그래밍을 해보자는 것.

DB와 연동하는 로직만 서블릿으로 작업하고, 화면은 jsp를 그대로 적용하는 것임.(이에 대한 적용 모델이 모델2임)
(비즈니스 로직과 관련된 처리 부분만 서블릿에 순수자바프로그래밍으로 구성하는 것)
서블릿 핵심기술 1) 클라이언트의 요청사항을 파싱하는 것.
              2) 파싱된 내용을 바탕으로 DB와의 연동을 수행하게끔 가교역할을 해줘야 함.

모델로직파트와의 연동을 수행해줘야하는데 
이때, 중간단에 서비스라고 하는 비즈니스로직을 이용하도록 한다.
         비즈니스로직의 실질적인 구현은 서비스라는 이름으로 구현하게 되는 것임


요청사항이 DB와 연동을 해야한다면 서비스단으로 클라이언트의 요청사항을 구현하는
실질적인 구현을 수행하는 로직을 비즈니스로직 레이어에서 서비스라는 이름으로 
구현을 해주도록 골격을 잡아주고 있었다.
***서비스레이어에서는 실질적으로 클라이언트의 요청사항에 대한 기능을 정의하도록 함.

서비스라는 비즈니스로직레이어를 하나 더 구성하여 처리를 왜 해야하는가(필요한 이유)? 
쇼핑몰 사이트에서 이벤트가 진행이 돼서 특정 상품을 구매했을 때 포인트 점수까지 부여가 된다면 
이벤트 점수와 상품 목록에 데이터는 테이블을 따로 생성하여 관리를 하게 될 것이다.

뭔가의 처리를 하는 과정에서 이벤트의 연결이 되어지면서 그 데이터가 서로 다른 테이블에 보관이 되어진다면 
상품 구매에 대한 처리를 끝내고, 구매한 사람에게 이벤트 기간 내에 포인트에 대한 점수를 부여해주는 작업을 
처리해줘야 한다. 그러려면 클라이언트의 요청은 하나였지만  그에 대한 처리는 서로 다른 테이블에서 
자동 업데이트가 되어져야 하는 것이다.
+) CRUD는 일반적으로 하나의 테이블당 하나의 자바빈을 연결하게끔 독립적인 구성이 되어지는 것이 문제가 발생되지 않음

이에 대한 요청에 대한 처리를 프리젠테이션레이어에서 다 해줘야 한다면 
컨트롤러가 파싱 뿐만 아니라 기능관련된 아주 복잡한 구조로 만들어져야 한다.
따라서 클라이언트에 대한 요청 부분을 따로 빼서 그 요청부분을 서비스단에서 처리를 하도록 구조를 잡도록 한다.
이는 유지보수의 빠른 대응과 요청에 대한 골격을 빠르게 잡는 등의 여러 장점들을 도입하기 위함이다.


-------------------------------------------------------------------------------------------------------------------------------------------------

[ 클라이언트에게 전송되어온 파라미터를 DB에 저장하는 로직 ]
클라이언트가 /BoardAddAction.bo의 최종적인 요청을 해옴

서블릿의 기술로 최초 요청에 대한 파싱의 기능을 처리함.
서블릿은 단순 파싱을 처리한 후에는 비스니스로직이 구현되어져 있는 실질적인 처리를 구현하는 서비스레이어를 구성하도록 한다.
어떠한 요청이 왔는지를 서비스레이어에 전달을 하면 서비스레이어에서 DB와 연동할 Repository의 DAO(CRUD)를 정의하여 
데이터베이스의 board테이블을 하나 만들고, 매핑할 수 있는 자바빈을 하나 정의하도록 한다.

클라이언트가 전송해온 파라미터를 꺼내와서 자바빈에 담은 다음에 
자바빈을 통해서 DAO에 전달해서 Create를 이용해서 DB에 저장하게끔 처리를 하고자하는 것이다.

서블릿에서 서비스를 호출하면서 해당 정보를 전달
-> 이에 대한 일반적인 구조를 상속의 구조로 잡아서 다형성을 적용하도록 한다.

실질적으로 DB와 연동하는 기술은 거의 모든 작업이 CRUD 내에서 동작이 되어진다.
컨트롤러에 요청이라는 것을 전달하면 서비스단에서는 DAO의 메소드를 처리하게 될 것이다.

데이터의 저장을 할 요청이 온다면 그 데이터의 저장 요청을 처리할 자료형이 서비스에 구현이 되어져야 할 것이다.
=> 서비스단에서는 그 처리를 수행할 것은 메소드로 정의가 되어져 있어야 한다.
   - 자바는 클래스 안에서만 메소드가 정의될 수 있다.

   BoardAddAction클래스를 정의해서 실질적인 요청을 처리할 기능을 제공하도록 함
   -> execute메소드를 정의해서 클라이언트의 파라미터를 꺼내와서 저장하는 식으로 (데이터 삽입 기능)
      실질적인 클라이언트의 요청사항을 구현해주도록 한다.


궁극적으로는 글을 등록을 하지만 
실질적으로는 글을 읽어오고, 삭제하고, 수정하는 기능들의 처리도 최종적으로 구현이 되어져야 한다.
=> 만약 BoardGetListAction.do로 요청이 온다면 
     이러한 자료형을 정의해서 여기다가 메소드를 정의해서 그 메소드로 DB에서 데이터를 읽어와서 
   자바빈에 담아서 화면으로 전달해서 화면에 그데이터를 출력하여 응답으로 보내주는 기능을 정의해야 할 것이다.
이 구조는 삭제와 수정도 동일하다. (클래스를 구현해서 메소드를 호출하는 구조로 정의될 것임)

클래스 하나당 DAO와 연동하는 동작은 메소드 하나로 정의가 되어질 것임
즉, 클라이언트의 요청사항에 대한 구조가 메소드 하나로 구현이 되어지는 것임

그 메소드의 이름을 각각 개별적으로 다르게 짓지말고, 기능에 따라 똑같이 하나의 execute이름으로 정의하도록 한다.
이때의 구조는 interface Action에서 execute()라는 추상메소드를 정의하도록 하는 것이다.
그렇게 앞으로 클라이언트의 요청 사항에 따라 구현하게 될 각각의 클래스에서 인터페이스를 구현하는 구조로 만들어서 execute의 추상메소드가 반드시 오버라이딩하여 정의할 수 있도록 구조를 잡아주도록 한다!!

위와 같은 구조의 장점은? 
메소드를 호출할 수 있으려면 new로 메모리 할당이 먼저 되어져야 한다.
이때 메모리의 할당은 Action action = new BoardAddAction();으로 정의해도 됨. (다형성의 관계)
(바라보는 대상을 Action의 부모로 지정하도록 한다.)
이후에 다형성의 관계로 오버라이딩된 action.execute()메소드를 호출 가능

실질적으로 호출되는 서비스레이어는 
클라이언트의 요청 사항에 따른 서비스레이어들을 하나의 대상으로 바라보도록 하고, 
이때 서비스레이어에 대한 메모리 할당만 처음에 기능에 따라 달리해주면 됨
그렇게 다형성에 의한 오버라이딩 구조를 통해 동일한 명령으로 서비스레이어를 호출하도록 하는 것이다.

execute메소드 안에서 클라이언트의 요청 사항을 처리하는 코드를 구현해서
하나의 자료형만을 바라보도록 하여 간단한 코드 구조를 만들어갈 수 있다.
ex) 고등학교친구든 대학교친구든 친구로 바라보는 것
*/
